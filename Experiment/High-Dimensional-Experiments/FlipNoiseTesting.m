% TestLPAccuracyWithGenerateSeparableData
% This script tests the accuracy of the LP approach on data generated by
% GenerateSeparableData for various dimensions, sample sizes, and deltas.
%
% It assumes you have:
%   - GenerateSeparableData(n, p, delta) available in the path.
%   - LS_Testing(A, B) function available to determine true separability.
%   - MATLAB’s Optimization Toolbox for linprog.
%
% The script loops over:
%   - dimensions: a vector of p values
%   - sizes: a vector of dataset sizes n
%   - deltas: a vector of label-retention probabilities
%   - epsilons: a vector of epsilons for sampling size = ceil(p/epsilon)
% It generates one dataset per (n, p, delta), computes true separability via LS_Testing,
% then for each epsilon, repeats random sampling and LP solves to estimate whether
% the sample LP decision matches the full-data separability. Results are saved
% to a CSV file.

clc;
clear;
close all;

% Parameters: adjust as needed
dimensions = [10, 20, 50, 100, 200, 500];            % ambient dimensions p
sizes = [30000];        % dataset sizes n
deltas = [ 0.6, 0.7, 0.8, 0.9, 1.0]; % label-retention probabilities
epsilons = 0.5:-0.05:0.01;        % epsilons for sampling size
n_repeats = 100;                   % number of repeats per setting

% linprog options
linprog_options = optimoptions('linprog', 'Display', 'none', 'Algorithm', 'interior-point');

% Initialize results container
results = [];  % rows: [p, n, delta, epsilon, accuracy_pct, LS_time, avg_sample_time, coefficient]

% Main loops
for p = dimensions
    for n = sizes
        for delta = deltas
            fprintf('--- Testing p=%d, n=%d, delta=%.2f ---\n', p, n, delta);
            % Generate one dataset for this setting
            try
                [X, y_obs, ~] = GenerateFlipNoise(n, p, delta);
            catch ME
                warning('Failed to generate data for p=%d, n=%d, delta=%.2f: %s', p, n, delta, ME.message);
                continue;
            end
            % X is n×p, y_obs is n×1 in {+1,-1}
            
            % Determine true separability via LS_Testing
            % LS_Testing expects A and B as separate sets: each column is a point
            idx_pos = (y_obs ==  1);
            idx_neg = (y_obs == -1);
            A_full = X(idx_neg, :)';  % points with label -1 as columns
            B_full = X(idx_pos, :)';  % points with label +1 as columns
            try
                tic;
                [LS_flag, ~, ~] = LS_Testing(A_full, B_full);
                LS_time = toc;
                % LS_flag assumed 1 if separable, else 0 or -1
                true_separable = (LS_flag == 1);
            catch ME
                warning('LS_Testing failed for p=%d, n=%d, delta=%.2f: %s', p, n, delta, ME.message);
                LS_time = NaN;
                true_separable = NaN;
            end
            
            % Prepare for sampling-based LP tests
            % Convert X,y_obs for convenience
            % values: p×n matrix of points as columns
            values = X';         % p×n
            y_full = y_obs(:)';  % 1×n row vector of ±1
            
            for eps = epsilons
                % Determine sample size: ceil(p/eps), but at most n, at least p+1
                sample_size = ceil(p / eps);
                sample_size = min(sample_size, n);
                sample_size = max(sample_size, p + 1);
                
                correct_count = 0;
                total_sample_time = 0;
                
                for trial = 1:n_repeats
                    indices = randperm(n, sample_size);
                    Xs = values(:, indices);   % p×sample_size
                    ys = y_full(indices);      % 1×sample_size
                    
                    % Build LP: find w∈R^p and b∈R s.t. y_i*(w' x_i + b) ≥ 0
                    % Equivalent to: for each i: y_i*(w' x_i + b) ≥ 1? 
                    % Here we test feasibility of y_i*(w' x_i + b) ≥ 0 with a slack variable? 
                    % The previous skeleton uses: A*theta ≤ b_vec, with theta = [w; b].
                    % We use: -diag(y) * [X'; ones] * [w; b] ≤ -eps_margin
                    % To avoid trivial zero solution, can use homogeneous separation: 
                    % Since we only test separability, require y_i*(w' x_i + b) ≥ 1.
                    % So: -y_i*(w' x_i + b) ≤ -1.
                    A_lp = -diag(ys) * [Xs' , ones(sample_size,1)];  % sample_size × (p+1)
                    b_lp = -ones(sample_size,1);
                    f = zeros(p+1,1);  % objective irrelevant for feasibility
                    % Solve LP feasibility
                    tic;
                    [~, ~, exitflag, ~] = linprog(f, A_lp, b_lp, [], [], [], [], linprog_options);
                    elapsed = toc;
                    total_sample_time = total_sample_time + elapsed;
                    
                    sample_separable = (exitflag == 1);
                    % Compare to true separability
                    if ~isnan(true_separable) && (sample_separable == true_separable)
                        correct_count = correct_count + 1;
                    end
                end
                
                if ~isnan(true_separable)
                    accuracy = 100 * correct_count / n_repeats;
                else
                    accuracy = NaN;
                end
                avg_time = total_sample_time / n_repeats;
                if ~isnan(LS_time) && ~isnan(avg_time) && avg_time > 0
                    coefficient = LS_time / avg_time;
                else
                    coefficient = NaN;
                end
                
                % Append result row
                results(end+1, :) = [p, n, delta, eps, accuracy, LS_time, avg_time, coefficient]; %#ok<AGROW>
                
                fprintf(' p=%d, n=%d, delta=%.2f, eps=%.3f | acc=%.1f%% | LS_time=%.3f s | avg_sample_time=%.3f s | coeff=%.2f\n', ...
                    p, n, delta, eps, accuracy, LS_time, avg_time, coefficient);
            end
            fprintf('======================================\n');
        end
    end
end

% Convert to table and save
T = array2table(results, ...
    'VariableNames', {'dimension','num_points','delta','epsilon','accuracy_pct','LS_time_sec','avg_sample_time_sec','coefficient'});
filename = 'LP_Accuracy_30000_FlipNoise_Results_100tries.csv';
writetable(T, filename);
fprintf('✅ Results saved to %s\n', filename);
